### 4.1.程序的开始和结束
本节讲述一个典型程序的开始运行和结束运行，引入引导代码让大家更容易的理解操作系统是如何运行一个程序的。

#### 4.1.1、main函数由谁调用
1. 编译链接时的引导代码。操作系统下的应用程序其实在`main`执行前也需要先执行一段引导代码才能去执行`main`，我们写应用程序时不用考虑引导代码的问题，编译连接时（准确说是链接时）由链接器将编译器中事先准备好的引导代码给连接进去和我们的应用程序一起构成最终的可执行程序。
> 引导代码：构建C语言运行环境。清BSS，重定位 ......
> 用`gcc -v xx.c`可以看到编译链接的过程，`file a.out`查看程序的信息

2. 运行时的加载器。加载器是操作系统中的程序，当我们去执行一个程序时（譬如`./a.out`，譬如代码中用`exec`族函数来运行）加载器负责将这个程序加载到内存中去执行这个程序。
3. 程序在编译连接时用**链接器**，运行时用**加载器**，这两个东西对程序运行原理非常重要。（编译时、运行时）
4. `argc`和`argv`的传参如何实现

#### 4.1.2、程序如何结束
1. 正常终止：`return`、`exit`、`_exit`
> 只能在`main`函数中用`return`来终止进程，在其他函数或子进程中用`return`只是返回值

2. 非正常终止：自己或他人发信号终止进程
> 比喻：公司里（操作系统），每个人（进程）都有自己的电话（信号），可以给别人打电话，别人也可以给你打电话。别人正在工作，你给别人打电话，让他去干什么事等，就打断了他的当前工作（执行）。别人给你打电话也一样。
> 但也不是可以随便给任何人打电话，比如说，一个下级员工给老总打电话，让他去干嘛，这肯定不行（级别权限）。
> 打电话（信号）也是有规矩（约定）的。

> 应用比如：程序进入死循环了，按下`Ctrl+C`就是让操作系统给进程发终止信号。（这种信号也可以通过设置来屏蔽掉，就像工作时不希望别人打扰）

#### 4.1.3、atexit 注册进程终止处理函数
1. 实验演示
```c++
/* 函数原型 */
int atexit(void (*function)(void));
```

示例：
```c++
#include <stdio.h>
#include <stdlib.h>

/* 进程终止处理函数 */
void func_1(void)
{
    printf("func_1\n");
}

void func_2(void)
{
    printf("func_2\n");
}

int main(void)
{
    printf("hello world.\n");

    /* 注册进程终止处理函数 */
    atexit(func_1);
    atexit(func_2);

    printf("main return \n");

    /* 执行到这里时，进程被终止，
     * 系统会自动调用这里注册的func执行
     */
    return 0;
}
```

结果：
```bash
$ ./a.out
hello world.
main return
func_2
func_1
```

2. `atexit`注册多个进程终止处理函数，先注册的后执行，后注册的先执行（先进后出，和栈一样）
> 进程终止前要做一些预处理，（比喻：为了不让每次上班时看到桌面是脏的，下班前要先把桌面整理干净，事先把这个工作安排好，下班就整理完再走）

3. `return`、`exit`和`_exit`的区别：`return`和`exit`效 果一样，都是会执行进程终止处理函数，但是用`_exit`终止进程时**并不**执行`atexit`注册的进程终止处理函数。
> 跟回调函数有关？

> 什么时候用这个呢？ 先看别人的程序中用到了，是怎么用的，在什么情况下用，以后你再用。
