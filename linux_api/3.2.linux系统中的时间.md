### 3.2.linux系统中的时间
#### 3.2.1、jiffies 的引入
1. `jiffies`是linux内核中的一个**全局变量**，这个变量用来记录以内核的节拍时间为单位时间长度的一个数值，亦即记录linux内核中经过了多少个节拍（时间段）
2. 内核配置的时候定义了一个**节拍时间**，实际上linux内核的调度系统工作时就是以这个节拍时间为时间片的。
3. `jiffies`变量开机时有一个基准值，然后内核每过一个节拍时间`jiffies`就会加`1`，然后到了系统的任意一个时间我们当前时间就被`jiffies`这个变量所标注。

#### 3.2.2、linux系统如何记录时间
1. 内核在开机启动的时候会读取 RTC 硬件，获取一个时间作为初始基准时间，这个基准时间对应一个`jiffies`值，这个jiffies 值作为我们开机时的基准 jiffies 值存在。
- （这个基准时间换算成 jiffies 值的方法是：用这个时间减去`1970-01-01 00:00:00 +0000(UTC)`(查找：man 2 time)，然后把这个时间段换算成`jiffies`数值）

2. 然后系统运行时每个时钟节拍的末尾都会给`jiffies`这个全局变量加`1`，因此操作系统就使用 jiffies 这个全局变量记录了下来当前的时间。当我们需要当前**时间点**时，就用 jiffies 这个时间点去计算
- （计算方法就是先把这个`jiffies`值对应的**时间段**算出来，然后加上`1970-01-01 00:00:00 +0000(UTC)`即可得到这个时间点）

3. 其实操作系统只在开机时读一次 RTC，整个系统运行过程中 RTC 是无作用的。RTC 的真正作用其实是在 OS 的2次开机之间进行时间的保存。
4. 理解时一定要点时间和段时间结合起来理解。`jiffies`这个变量记录的其实是**段时间**
- （其实就是当前时间和`1970-01-01 00:00:00 +0000(UTC)`这个时间的**差值**）

5. 一个时间节拍的时间取决于操作系统的配置，现代linux系统一般是`10ms`或者`1ms`。这个时间其实就是**调度时间**，在内核中用`HZ`来记录和表示。
> 如果`HZ`定义成`1000`，那么时钟节拍就是`1/HZ`，也就是`1ms`。这些在学习驱动时会用到。

#### 3.2.3、linux中时间相关的系统调用
1. 常用的时间相关的API和C库函数有9个：`time`/`ctime`/`localtime`/`gmtime`/`mktime`/`asctime`/`strftime`/`gettimeofday`/`settimeofday`

![时间格式之间的转换](https://github.com/zfrime/blog/blob/master/linux_api/Image/time.png)

2. `time`系统调用返回当前时间以**秒**为单位的距离`1970-01-01 00:00:00 +0000(UTC)`过去的秒数。这个`time`内部就是用`jiffies`换算得到的秒数。其他函数基本都是围绕着 time 来工作的。
3. `gmtime`和`localtime`会把`time`得到的秒数变成一个`struct tm`结构体表示的时间。`mktime`用来完成相反方向的转换（`struct tm`到`time_t`）
- 区别是`gmtime`得到的是国际时间，
- 而`localtime`得到的是本地
> （指的是你运行`localtime`函数的程序所在的计算机所设置的时区对应的本地时间）时间。

4. 如果从`struct tm`出发想得到字符串格式的时间，可以用`asctime`或者`strftime`都可以。（如果从`time_t`出发想得到字符串格式的时间用`ctime`即可）
5. `gettimeofday`返回的时间是由`struct timeval`和`struct timezone`这两个结构体来共同表示的，其中`timeval`表示时间，而`timezone`表示时区。`settimeofday`是用来设置当前的时间和时区的。
6. 总结：不管用哪个系统调用，最终得到的时间本质上都是一个时间（这个时间最终都是从kernel中记录的`jiffies`中计算得来的），只不过不同的函数返回的时间的**格式**不同，**精度**不同。
